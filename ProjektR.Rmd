---
title: "Nieruchomości w Polsce"
author: "Natalia Cebulska, Natalia Leżuchowska, Błażej Bojka, Kacper Karnath"
output:
  pdf_document: default
---

```{r setup, include=FALSE}
library(tufte)
library(tidyverse)
library(dplyr)
library(tidyr)
library(readr)
library(editrules)
library(VIM)
library(corrplot)
library(deducorrect)
library(ISLR)
library(outliers)
library(naniar)
library(ggplot2)
library(plotly)
library(knitr)
library(gtsummary)


data <- read.csv(file = "apartments_pl_2024_06.csv")
data
```

# Przygotowanie do data cleansing, data wrangling

## Wczytanie oraz wyświetlenie danych

```{r}
data <- read_csv("apartments_pl_2024_06.csv")
head(data)
```

## Sprawdzenie jakie mamy typy danych
```{r}
glimpse(data)
```

## Sprawdzenie czy mamy prakujące obserwacje oraz ile ich jest
```{r}
n_miss(data)
```

## Sprawdzenie ile brakujących obserwacji jest w każdej kolumnie
```{r}
miss_var_summary(data)
```

Największe braki danych w kolumnach condition, buildingMaterial, type, floor oraz buildYear (w każdym powyżej 15%).


## Pokazanie ile jest brakujących obserwacji w wierszach
```{r}
miss_case_table(data)
```

Większość obserwacji ma od 1 do 3 braków, co pozwala na zastosowanie imputacji brakujących danych.


## Wizualizacja braków danych
```{r}
vis_miss(data, cluster = TRUE, sort_miss = TRUE)
```

Graficzne ukzanie, w których kolumnach mamy najwięcej brakujacych danych. Wykres potwierdza, że są to kolumny condition (74%), building material (41%), type (20%), floor (17%) oraz buildYear (16%)


## Wykres przedstawiający wzorce braków danych
```{r}
gg_miss_upset(data)
```

Z wykresu możemy odczytać, że najwięcej braków danych występuje jedynie w kolumnie condition, bez współwystępowania braku w innych kolumnach. Większa liczba braków danych występuje też zależnie zarówno w kolumnie condition jak i buildingMaterial oraz w kolumnach condition, buildingMaterial i type


## Grupowanie braków według miasta
```{r}
data %>% 
  group_by(city) %>% 
  miss_var_summary() %>% 
  View()
```

Nie ma istotnych różnic w brakach danych między miastami. Ww wszystkich największy odsetek brakujacych danych stanowi kolumna condition.


## Sprawdzenie wartości odstających

```{r}
numeric_columns <- data %>% select(where(is.numeric)) %>% colnames()

for (col in numeric_columns) {
  cat("\nKolumna:", col, "\n")
  
  # Tworzenie wykresu pudełkowego
  boxplot_result <- boxplot(data[[col]], 
                            main = paste("Wykres pudełkowy dla", col), 
                            col = "lightblue", 
                            ylab = col)
  

}
```


Analiza wartości odstających:

Cena -> wartości odstające powyżej 2mln, do 3mn - brak podstaw do usuwania dancyh odstających, gdyż są to realne ceny za mieszkania

Metry kwadratowe -> wartości odstające do max 140m2 - mają sens

Pokoje, piętra oraz liczba pięter -> niewielka liczba możliwych wartości odstających, piętro na kt.orym jest mieszkanie nie przewyższa ogólnej liczby pięter

Rok budowy -> wartości odstające poniżej roku 1900, lecz powyżej roku 1850 - mają sens

Dużo wartości odstających w odległościach do różnych punkót usłgowych, lecz poniżej 5km - wyniki mają sens

Na podstawie powyższej analizy, możemy stwierdzic, że pomimo występowania wartości odstających nie wyglądają one na błędy i nasze dane są spójne, brak konieczności usuwania danych odstających



# Imputacja danych

1. Condition

 Z racji tego, że stan normalny zazwyczaj nie jest określany w ogłoszeniach nieruchomości (chcemy się pochwalić stanem premium lub zaznaczyć niski standard mieszkania), z logicznego punktu widzenia, możemy uzupełnić braki danych w tej kolumnie jako 'standard'
```{r}
data1Condition <- data %>% 
  mutate(condition = ifelse(is.na(condition), "Standard", condition))
View(data1Condition)
na_count_condition <- sum(is.na(data1Condition$condition))
print(na_count_condition)
```

Brak wartości NA



2. Building Material 

Zmienna ta nie powinna mieć istotnego wpływu na cenę, kupujący zazwyczaj nie zwacają uwagi na aspekt matriałów użytych do budowy domu, w którym znajduje się mieszkanie. Aby zastąpić brakujące obserwacje użyjemy sformułowania "Material is not known/different building material". Jeśli w późniejszej analizie zostanie wykazany wpływ tego czynnika na cenę, bedziemy brać go pod uwagę.
```{r}
data2Condition.buildingMaterial <- data1Condition %>% 
  mutate(buildingMaterial = ifelse(is.na(buildingMaterial), "Material is not known/different building material", buildingMaterial))
View(data2Condition.buildingMaterial)
na_count_condition <- sum(is.na(data2Condition.buildingMaterial$buildingMaterial))
print(na_count_condition)
```

Brak wartości NA



3.Type

Brakujące wartości zostaną uzupełnione z użyciem metody k-NN (k-Nearest Neighbors), która zastąpi nam brakujące wartości na podstawie sąsiadujących obserwacji, które są najbardziej podobne do brakującego wiersza
```{r}
dataCBT <- kNN(data2Condition.buildingMaterial,
                    variable = c("type"),        
                    k = 5,                       
                    weightDist = TRUE)          
View(dataCBT)

na_count_condition <- sum(is.na(dataCBT$type))
print(na_count_condition)
```

Brak wartości NA



4. Floor Count 

Brakujące wartości uzupełnione na podstawie grupowania oraz wyliczania mediany wartości w tychże grupach. Do porównania zostały użyte zmienne city, type oraz condition.
```{r}
dataCBTFC <- dataCBT %>%
  group_by(city, type, condition) %>%  
  mutate(floorCount = ifelse(is.na(floorCount), median(floorCount, na.rm = TRUE), floorCount)) %>%
  ungroup()
View(dataCBTFC)
na_count_condition <- sum(is.na(dataCBTFC$floorCount))
print(na_count_condition)
```

Brak wartości NA


5.Floor 

Brakujące wartości uzupełnione na podstawie grupowania oraz wyliczania mediany wartości w tychże grupach. Do porównania zostały użyte zmienne floorCount oraz type.
```{r}
data2 <- dataCBTFC %>%
  group_by(floorCount, type) %>%
  mutate(floor = ifelse(is.na(floor), median(floor, na.rm = TRUE), floor)) %>%
  ungroup()
View(data2)
na_count_condition <- sum(is.na(data2$floor))
print(na_count_condition)
```

Brak wartości NA



6. Build Year

Brakujące wartości uzupełnione na podstawie grupowania oraz wyliczania mediany wartości w tychże grupach. Do porównania zostały użyte zmienne floorCount, type, city.
```{r}
data3 <- data2 %>%
  group_by(floorCount, type, city) %>%
  mutate(buildYear = ifelse(is.na(buildYear), median(buildYear, na.rm = TRUE), buildYear)) %>%
  ungroup()
View(data3)
na_count_condition <- sum(is.na(data3$buildYear))
print(na_count_condition)
```


37 wartości NA, ponawiamy imputację danych za pomocą mediany, lecz tym razem dla całego zbioru danych (liczba brakujących obserwacji jest bardzo mała)

```{r}
data4 <- data3 %>%
  mutate(buildYear = ifelse(is.na(buildYear), 
                            median(buildYear, na.rm = TRUE), 
                            buildYear))
na_count_condition <- sum(is.na(data4$buildYear))
print(na_count_condition)
```

Brak wartości NA



7.has Elevator

Brakujące wartości zostaną uzupełnione z użyciem metody k-NN (k-Nearest Neighbors), która zastąpi nam brakujące wartości na podstawie sąsiadujących obserwacji, które są najbardziej podobne do brakującego wiersza
```{r}
data5 <- kNN(data4, 
                variable = c("hasElevator"),
                k = 5, 
                weightDist = TRUE)
View(data5)

na_count_condition <- sum(is.na(data5$hasElevator))
print(na_count_condition)
```

Brak wartości NA



8. Distance - college, clinic, restaurant, pharmacy, postoffice, kindergarten, school

Mała liczba wartości NA, imputacja może być wyliczana na podstawie mediany dla wszystkich obserwacji

```{r}
data1 <- data5 %>%
  mutate(collegeDistance = ifelse(is.na(collegeDistance), median(collegeDistance, na.rm = TRUE), collegeDistance))

miss_var_summary(data1)

data2 <- data1 %>%
  mutate(clinicDistance = ifelse(is.na(clinicDistance), median(clinicDistance, na.rm = TRUE), clinicDistance))

miss_var_summary(data2)

data3 <- data2 %>%
  mutate(restaurantDistance = ifelse(is.na(restaurantDistance), median(restaurantDistance, na.rm = TRUE), restaurantDistance))

miss_var_summary(data3)

data4 <- data3 %>%
  mutate(pharmacyDistance = ifelse(is.na(pharmacyDistance), median(pharmacyDistance, na.rm = TRUE), pharmacyDistance))

miss_var_summary(data4)

data5 <- data4 %>%
  mutate(postOfficeDistance = ifelse(is.na(postOfficeDistance), median(postOfficeDistance, na.rm = TRUE), postOfficeDistance))

miss_var_summary(data5)

data6 <- data5 %>%
  mutate(kindergartenDistance = ifelse(is.na(kindergartenDistance), median(kindergartenDistance, na.rm = TRUE), kindergartenDistance))

miss_var_summary(data6)

data7 <- data6 %>%
  mutate(schoolDistance = ifelse(is.na(schoolDistance), median(schoolDistance, na.rm = TRUE), schoolDistance))
miss_var_summary(data7)
```


**BRAK WARTOŚCI ODSTAJĄCYCH W NASZYM ZBIORZE DANYCH**


## WNIOSKOWANIE STATYCZNE 

## Sprawdzenie czy średnie ceny różnią się między miastami (test ANOVA)

```{r}
anova_model <-aov(price ~ city, data = data7)
summary(anova_model)

if(summary(anova_model)[[1]]$`Pr(>F)`[1] < 0.05) {
  tukey_result <- TukeyHSD(anova_model)
  print(tukey_result)}
```

W testach Tukeya większość dużych miast (Warszawa, Kraków, Gdańsk, Wrocław, Poznań) wykazuje istotnie wyższe ceny niż mniejsze ośrodki (Białystok, Częstochowa, Radom, Łódź).
Największe różnice cenowe występują między Warszawą a mniejszymi miastami, takimi jak Białystok i Częstochowa.

## Przeprowadzenie testu ANOVA, aby sprawdzić, czy średnie ceny różnią się między typami mieszkań
```{r}
anova_type <- aov(price ~ type, data = data7)
summary(anova_type)
```

Istnieją istotne różnice w cenach mieszkań 

## Przeprowadzenie testu Tukeya w celu określenia, które pary typów mieszkań mają istotne różnice w cenach. 

```{r}
tukey_result <- TukeyHSD(anova_model)
print(tukey_result)
```

Test Tukeya potwierdza głębokie zróżnicowanie cen mieszkań w Polsce.
Najwyższe ceny występują w dużych aglomeracjach, podczas gdy mniejsze miasta pozostają znacznie tańsze.
Miasta o najwyższych cenach mieszkań: Warszawa, Kraków, Gdańsk, Wrocław i Poznań mają istotnie wyższe
ceny mieszkań w porównaniu z większością innych miast (np. różnice sięgające nawet 500 000 PLN).
Przykład: warszawa-bialystok: różnica +541 443 PLN (p < 0.0001). krakow-bialystok: różnica +430 477 PLN (p < 0.0001).

## Przeprowadzenie testu ANOVA, aby sprawdzić, czy średnie ceny różnią się między typami mieszkań

```{r}
anova_type <- aov(price ~ type, data = data7)
summary(anova_type)

if (summary(anova_type)[[1]]$`Pr(>F)`[1] < 0.05) {
  tukey_type <- TukeyHSD(anova_type)
  print(tukey_type)
}
```

Apartamentowce wymagają większego kapitału, bloki mieszkalne są bardziej przystępne cenowo, a kamienice stanowią pośrednią opcję.
Porównanie: blok mieszkalny vs apartamentowiec: Bloki mieszkalne są średnio o 365 815 zł tańsze niż apartamentowce.
Porównanie: kamienica vs apartamentowiec: Kamienice są średnio o 211 115 zł tańsze niż apartamentowce.
Porównanie: kamienica vs blok mieszkalny: Kamienice są średnio o 154 701 zł droższe niż bloki mieszkalne.

### Korelacja między ceną a odległością od uczelni
```{r}
cor_test_college <- cor.test(data7$price, data7$collegeDistance, method = "pearson")
print(cor_test_college)
```

Bliskość uczelni nie jest istotnym czynnikiem kształtującym ceny mieszkań.


### Korelacja między ceną a odległością od centrum
```{r}
cor_test_centre <- cor.test(data7$price, data7$centreDistance, method = "pearson")
print(cor_test_centre)
```

Odległość od centrum ma bardzo niewielki wpływ na ceny mieszkań.

### Korelacja między ceną a rokiem budowy
```{r}
cor_test_buildYear <- cor.test(data7$price, data7$buildYear, method = "pearson")
print(cor_test_buildYear)
```

Nowsze budynki mają tendencję do wyższych cen

## Przeprowadzenie testu ANOVA, aby sprawdzić, czy średnie ceny różnią się między stanami mieszkań
```{r}
anova_condition <- aov(price ~ condition, data = data7)
summary(anova_condition)
```

Stan mieszkania ma znaczący wpływ na cenę

```{r}
if (summary(anova_condition)[[1]]$`Pr(>F)`[1] < 0.05) {
  tukey_condition <- TukeyHSD(anova_condition)
  print(tukey_condition)
}

ggplot(data7, aes(x = condition, y = price, fill = condition)) +
  geom_boxplot(outlier.color = "red") +
  labs(title = "Średnie ceny mieszkań w zależności od stanu", x = "Stan mieszkania", y = "Cena (PLN)") +
  theme_minimal()
```

Średnie ceny mieszkań znacząco różnią się w zależności od stanu mieszkania:
Mieszkania w stanie premium mają najwyższe średnie ceny.
Mieszkania w stanie Standard są droższe niż w stanie low, ale tańsze niż premium.
Stan low wiąże się z najniższymi średnimi cenami mieszkań.

##Tworzenie tabeli kontyngencji dla miasta i typu mieszkania
```{r}
contingency_table <- table(data7$city, data7$type)
```

## Przeprowadzenie testu Chi-kwadrat
```{r}
chi_square_result <- chisq.test(contingency_table)
print(chi_square_result)
print(chi_square_result$expected)
mosaicplot(contingency_table, main = "Mozaikowy wykres zależności", color = TRUE, las = 3)
```

## Przeprowadzenie testu t-Studenta, aby porównać ceny mieszkań z windą i bez windy
```{r}
t_test_elevator <- t.test(price ~ hasElevator, data = data7)
print(t_test_elevator)
```

Wyniki testu wskazują, że obecność windy ma istotny wpływ na cenę mieszkań. 
Mieszkania z windą są średnio droższe od mieszkań bez windy o około 177 000 PLN.
Może to wynikać z faktu, że winda jest istotnym udogodnieniem, szczególnie w budynkach 
wielopiętrowych. Wpływa na postrzeganą wartość nieruchomości.

```{r}
ggplot(data7, aes(x = hasElevator, y = price, fill = hasElevator)) +
  geom_boxplot(outlier.color = "red") +
  labs(title = "Porównanie cen mieszkań z windą i bez windy",
       x = "Czy mieszkanie ma windę?",
       y = "Cena (PLN)") +
  theme_minimal()
```

## Test Kruskala-Wallisa do porównania cen między miastami
```{r}
kruskal_result <- kruskal.test(price ~ city, data = data7)
print(kruskal_result)
```

Wyniki testu Kruskala-Wallisa wskazują, że istnieją statystycznie istotne 
różnice w rozkładach cen mieszkań między miastami.

```{r}
pairwise.wilcox.test(data7$price, data7$city, p.adjust.method = "bonferroni")
```

Większość miast różni się istotnie pod względem median cen mieszkań, co wskazuje 
na zróżnicowany rynek nieruchomości w zależności od lokalizacji.

```{r}
ggplot(data7, aes(x = city, y = price, fill = city)) +
  # geom_boxplot(outlier.color = "blue") +
  labs(title = "Porównanie cen mieszkań w różnych miastach",
       x = "Miasto",
       y = "Cena (PLN)") + theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

##Wykorzystanie pakietu ggstatsplot
```{r}
install.packages("ggstatsplot")
library(ggstatsplot)
library(dplyr)
```

```{r}
top_cities <- data7 %>%
  group_by(city) %>%
  summarise(mean_price = mean(price)) %>%
  arrange(desc(mean_price)) %>%
  slice(1:5) 

filtered_data <- data7 %>%
  filter(city %in% top_cities$city)

ggbetweenstats(
  data = filtered_data,
  x = city,
  y = price,
  type = "parametric",
  pairwise.comparisons = TRUE,
  pairwise.display = "significant", 
  mean.plotting = FALSE,           
  p.adjust.method = "bonferroni",
  ggtheme = ggplot2::theme_minimal(),
  title = "Porównanie cen mieszkań w wybranych miastach"
) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_brewer(palette = "Set2")
```

## Dodanie testów zgodności rozkładu
```{r}
install.packages("nortest")
library(nortest)
lillie.test(data7$price) 
```

## Analiza wielowymiarowa – rozszerzenie modelu regresji
```{r}
lm_interaction <- lm(price ~ rooms * buildYear, data = data7)
summary(lm_interaction)
plot(lm_model)
```

## Przykłady rozszerzonych analiz i wizualizacji
## Porównanie odległości od uczelni i od centrum w kontekście cen mieszkań
```{r}
ggscatterstats(
  data = data7,
  x = collegeDistance,
  y = price,
  title = "Korelacja między ceną a odległością od uczelni",
  xlab = "Odległość od uczelni (km)",
  ylab = "Cena (PLN)")
```
